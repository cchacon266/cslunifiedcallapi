<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSLibrary: CSLibrary.Threading.MonitorEx Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CSLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_c_s_library.html">CSLibrary</a></li><li class="navelem"><a class="el" href="namespace_c_s_library_1_1_threading.html">Threading</a></li><li class="navelem"><a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html">MonitorEx</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_c_s_library_1_1_threading_1_1_monitor_ex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CSLibrary.Threading.MonitorEx Class Reference<span class="mlabels"><span class="mlabel">sealed</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Enhanced alternative to the T:System.Threading.Monitor class. Provides a mechanism that synchronizes access to objects.  
 <a href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4d1ea54ec07cedffc762ef128c54d5cf" id="r_a4d1ea54ec07cedffc762ef128c54d5cf"><td class="memItemLeft" align="right" valign="top"><a id="a4d1ea54ec07cedffc762ef128c54d5cf" name="a4d1ea54ec07cedffc762ef128c54d5cf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventFlags</b> { <b>PULSE</b> = 1
, <b>RESET</b> = 2
, <b>SET</b> = 3
 }</td></tr>
<tr class="separator:a4d1ea54ec07cedffc762ef128c54d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6273d5556606cfef4dc02133be577c8a" id="r_a6273d5556606cfef4dc02133be577c8a"><td class="memItemLeft" align="right" valign="top"><a id="a6273d5556606cfef4dc02133be577c8a" name="a6273d5556606cfef4dc02133be577c8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MonitorEx</b> ()</td></tr>
<tr class="memdesc:a6273d5556606cfef4dc02133be577c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new monitor, not owned by any thread. <br /></td></tr>
<tr class="separator:a6273d5556606cfef4dc02133be577c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0494a161c275aa632831500afcffaa32" id="r_a0494a161c275aa632831500afcffaa32"><td class="memItemLeft" align="right" valign="top"><a id="a0494a161c275aa632831500afcffaa32" name="a0494a161c275aa632831500afcffaa32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Enter</b> ()</td></tr>
<tr class="memdesc:a0494a161c275aa632831500afcffaa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters the monitor (locks it), blocking until the lock is held. If the monitor is already held by the current thread, its lock count is incremented. <br /></td></tr>
<tr class="separator:a0494a161c275aa632831500afcffaa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e818188bc04315dc7cf4c24b0e8fc23" id="r_a8e818188bc04315dc7cf4c24b0e8fc23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#a8e818188bc04315dc7cf4c24b0e8fc23">TryEnter</a> ()</td></tr>
<tr class="memdesc:a8e818188bc04315dc7cf4c24b0e8fc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to enter the monitor (locking it) but does not block if the monitor is already owned.  <br /></td></tr>
<tr class="separator:a8e818188bc04315dc7cf4c24b0e8fc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38fc7f6329254441c9438708149ede8" id="r_ac38fc7f6329254441c9438708149ede8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#ac38fc7f6329254441c9438708149ede8">Exit</a> ()</td></tr>
<tr class="memdesc:ac38fc7f6329254441c9438708149ede8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a level of locking, unlocking the monitor itself if the lock count becomes 0.  <br /></td></tr>
<tr class="separator:ac38fc7f6329254441c9438708149ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86516769092b828abc960f38daf81cd0" id="r_a86516769092b828abc960f38daf81cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#a86516769092b828abc960f38daf81cd0">Pulse</a> ()</td></tr>
<tr class="memdesc:a86516769092b828abc960f38daf81cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulses the monitor once - a single waiting thread will be released and continue its execution after the current thread has exited the monitor. Unlike Pulse on the normal framework, no guarantee is made about which thread is woken.  <br /></td></tr>
<tr class="separator:a86516769092b828abc960f38daf81cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e175c297df8078f9bb9433d1b880b7e" id="r_a4e175c297df8078f9bb9433d1b880b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#a4e175c297df8078f9bb9433d1b880b7e">PulseAll</a> ()</td></tr>
<tr class="memdesc:a4e175c297df8078f9bb9433d1b880b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulses the monitor such that all waiting threads are woken up. All threads will then try to regain the lock on this monitor. No order for regaining the lock is specified.  <br /></td></tr>
<tr class="separator:a4e175c297df8078f9bb9433d1b880b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c4a12efaad90786250d988c41bd5d" id="r_a773c4a12efaad90786250d988c41bd5d"><td class="memItemLeft" align="right" valign="top"><a id="a773c4a12efaad90786250d988c41bd5d" name="a773c4a12efaad90786250d988c41bd5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Wait</b> ()</td></tr>
<tr class="memdesc:a773c4a12efaad90786250d988c41bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquishes the lock on this monitor (whatever the lock count is) and waits for the monitor to be pulsed. After the monitor has been pulsed, the thread blocks again until it has regained the lock (at which point it will have the same lock count as it had before), and then the method returns. <br /></td></tr>
<tr class="separator:a773c4a12efaad90786250d988c41bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f91dc0a4dd8c36f2965d9a408a894f" id="r_a47f91dc0a4dd8c36f2965d9a408a894f"><td class="memItemLeft" align="right" valign="top"><a id="a47f91dc0a4dd8c36f2965d9a408a894f" name="a47f91dc0a4dd8c36f2965d9a408a894f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Wait</b> (int timeout)</td></tr>
<tr class="memdesc:a47f91dc0a4dd8c36f2965d9a408a894f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquishes the lock on this monitor (whatever the lock count is) and waits for the monitor to be pulsed. After the monitor has been pulsed, the thread blocks again until it has regained the lock (at which point it will have the same lock count as it had before), and then the method returns. <br /></td></tr>
<tr class="separator:a47f91dc0a4dd8c36f2965d9a408a894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e84d0a5a0ca8ffd9475949ab8d099f" id="r_a11e84d0a5a0ca8ffd9475949ab8d099f"><td class="memItemLeft" align="right" valign="top"><a id="a11e84d0a5a0ca8ffd9475949ab8d099f" name="a11e84d0a5a0ca8ffd9475949ab8d099f"></a>
static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><b>CreateEvent</b> (IntPtr lpEventAttributes, [In, MarshalAs(UnmanagedType.Bool)] bool bManualReset, [In, MarshalAs(UnmanagedType.Bool)] bool bIntialState, [In, MarshalAs(UnmanagedType.BStr)] string lpName)</td></tr>
<tr class="separator:a11e84d0a5a0ca8ffd9475949ab8d099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c3feb8715fd3a4933170fb094c7792" id="r_a22c3feb8715fd3a4933170fb094c7792"><td class="memItemLeft" align="right" valign="top"><a id="a22c3feb8715fd3a4933170fb094c7792" name="a22c3feb8715fd3a4933170fb094c7792"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>CloseHandle</b> (IntPtr hEvent)</td></tr>
<tr class="separator:a22c3feb8715fd3a4933170fb094c7792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b7ce7560c83799c4e8e7dd5281e91f" id="r_a32b7ce7560c83799c4e8e7dd5281e91f"><td class="memItemLeft" align="right" valign="top"><a id="a32b7ce7560c83799c4e8e7dd5281e91f" name="a32b7ce7560c83799c4e8e7dd5281e91f"></a>
static Int32&#160;</td><td class="memItemRight" valign="bottom"><b>WaitForSingleObject</b> (IntPtr hEvent, Int32 <a class="el" href="class_c_s_library_1_1_threading_1_1_monitor_ex.html#a773c4a12efaad90786250d988c41bd5d">Wait</a>)</td></tr>
<tr class="separator:a32b7ce7560c83799c4e8e7dd5281e91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b03c38d2f5b16ec4fffae736d31ff" id="r_ae52b03c38d2f5b16ec4fffae736d31ff"><td class="memItemLeft" align="right" valign="top"><a id="ae52b03c38d2f5b16ec4fffae736d31ff" name="ae52b03c38d2f5b16ec4fffae736d31ff"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>WaitForMultipleObjects</b> (uint cObjects, IntPtr[] hEvent, bool fWaitAll, uint dwTimeout)</td></tr>
<tr class="separator:ae52b03c38d2f5b16ec4fffae736d31ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8330552ccf305d621402a6b3d27b43fc" id="r_a8330552ccf305d621402a6b3d27b43fc"><td class="memItemLeft" align="right" valign="top"><a id="a8330552ccf305d621402a6b3d27b43fc" name="a8330552ccf305d621402a6b3d27b43fc"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetEvent</b> (IntPtr hEvent, [In] EventFlags dEvent)</td></tr>
<tr class="separator:a8330552ccf305d621402a6b3d27b43fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a927cfb3d53cab0bfec5ba7aeb18e18bb" id="r_a927cfb3d53cab0bfec5ba7aeb18e18bb"><td class="memItemLeft" align="right" valign="top"><a id="a927cfb3d53cab0bfec5ba7aeb18e18bb" name="a927cfb3d53cab0bfec5ba7aeb18e18bb"></a>
object&#160;</td><td class="memItemRight" valign="bottom"><b>stateLock</b> = new object()</td></tr>
<tr class="memdesc:a927cfb3d53cab0bfec5ba7aeb18e18bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to be used as a monitor for state changing. <br /></td></tr>
<tr class="separator:a927cfb3d53cab0bfec5ba7aeb18e18bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8e88d8044873b6d790832df23fbf4819" id="r_a8e88d8044873b6d790832df23fbf4819"><td class="memItemLeft" align="right" valign="top"><a id="a8e88d8044873b6d790832df23fbf4819" name="a8e88d8044873b6d790832df23fbf4819"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>INFINITE</b> = 0xffffffff</td></tr>
<tr class="separator:a8e88d8044873b6d790832df23fbf4819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208dc60f926d843b36fdd8b2c7601317" id="r_a208dc60f926d843b36fdd8b2c7601317"><td class="memItemLeft" align="right" valign="top"><a id="a208dc60f926d843b36fdd8b2c7601317" name="a208dc60f926d843b36fdd8b2c7601317"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>WAIT_TIMEOUT</b> = 258</td></tr>
<tr class="separator:a208dc60f926d843b36fdd8b2c7601317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0850abed7e2fe383247e5f41bc08a83" id="r_aa0850abed7e2fe383247e5f41bc08a83"><td class="memItemLeft" align="right" valign="top"><a id="aa0850abed7e2fe383247e5f41bc08a83" name="aa0850abed7e2fe383247e5f41bc08a83"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>WAIT_FAILED</b> = 0xffffffff</td></tr>
<tr class="separator:aa0850abed7e2fe383247e5f41bc08a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa008daeae4468b5560fdd88b856dfd14" id="r_aa008daeae4468b5560fdd88b856dfd14"><td class="memItemLeft" align="right" valign="top"><a id="aa008daeae4468b5560fdd88b856dfd14" name="aa008daeae4468b5560fdd88b856dfd14"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>WAIT_OBJECT_0</b> = 0x00000000</td></tr>
<tr class="separator:aa008daeae4468b5560fdd88b856dfd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Enhanced alternative to the T:System.Threading.Monitor class. Provides a mechanism that synchronizes access to objects. </p>
<dl class="section see"><dt>See also</dt><dd>T:System.Threading.Monitor</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac38fc7f6329254441c9438708149ede8" name="ac38fc7f6329254441c9438708149ede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38fc7f6329254441c9438708149ede8">&#9670;&#160;</a></span>Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLibrary.Threading.MonitorEx.Exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a level of locking, unlocking the monitor itself if the lock count becomes 0. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SynchronizationLockException</td><td>If the current thread does not own the monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86516769092b828abc960f38daf81cd0" name="a86516769092b828abc960f38daf81cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86516769092b828abc960f38daf81cd0">&#9670;&#160;</a></span>Pulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLibrary.Threading.MonitorEx.Pulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulses the monitor once - a single waiting thread will be released and continue its execution after the current thread has exited the monitor. Unlike Pulse on the normal framework, no guarantee is made about which thread is woken. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SynchronizationLockException</td><td>If the current thread does not own the monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e175c297df8078f9bb9433d1b880b7e" name="a4e175c297df8078f9bb9433d1b880b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e175c297df8078f9bb9433d1b880b7e">&#9670;&#160;</a></span>PulseAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLibrary.Threading.MonitorEx.PulseAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulses the monitor such that all waiting threads are woken up. All threads will then try to regain the lock on this monitor. No order for regaining the lock is specified. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SynchronizationLockException</td><td>If the current thread does not own the monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e818188bc04315dc7cf4c24b0e8fc23" name="a8e818188bc04315dc7cf4c24b0e8fc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e818188bc04315dc7cf4c24b0e8fc23">&#9670;&#160;</a></span>TryEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSLibrary.Threading.MonitorEx.TryEnter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to enter the monitor (locking it) but does not block if the monitor is already owned. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the current thread now owns the monitor. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Projects/GitHub/CSL-Callback-Unified-SDK-App - NET7/Library Source/CSLibrary.Threading/<b>__CSLibrary.Threading.cs</b></li>
<li>C:/Projects/GitHub/CSL-Callback-Unified-SDK-App - NET7/Library Source/CSLibrary.Threading/<b>CSLibrary.Threading.cs</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
